// Advanced GPU-based culling and LOD selection for Gaussian Splats
// Supports frustum culling, distance culling, and LOD generation
#pragma kernel FrustumCull
#pragma kernel DistanceCull
#pragma kernel LODSelect
#pragma kernel CombinedCullAndLOD

// Input buffers
StructuredBuffer<float3> _InputPositions;
StructuredBuffer<float3> _InputScales;
StructuredBuffer<float4> _InputRotations;
StructuredBuffer<float4> _InputColors;
StructuredBuffer<float> _InputOpacities;

// Output buffers
RWStructuredBuffer<float3> _OutputPositions;
RWStructuredBuffer<float3> _OutputScales;
RWStructuredBuffer<float4> _OutputRotations;
RWStructuredBuffer<float4> _OutputColors;
RWStructuredBuffer<float> _OutputOpacities;

// Culling results
RWStructuredBuffer<uint> _VisibilityMask; // 1 if visible, 0 if culled
RWStructuredBuffer<uint> _VisibleIndices; // Compact list of visible indices
RWStructuredBuffer<uint> _VisibleCount; // Counter for visible splats

// Camera and culling parameters
float4x4 _ViewProjectionMatrix;
float4x4 _ViewMatrix;
float3 _CameraPosition;
float3 _CameraForward;
float _NearClip;
float _FarClip;
float _FrustumPadding; // Extra padding for frustum bounds

// LOD parameters
float4 _LODDistances; // x=LOD0, y=LOD1, z=LOD2, w=LOD3
float4 _LODDecimation; // Decimation factor for each LOD (1.0 = all, 0.5 = half, etc.)
int _CurrentLODLevel;

// Splat count
uint _SplatCount;

// Utility functions
float3 ApplyQuaternionRotation(float3 v, float4 q)
{
    float3 qvec = q.xyz;
    float3 uv = cross(qvec, v);
    float3 uuv = cross(qvec, uv);
    return v + 2.0 * (uv * q.w + uuv);
}

float GetMaxScale(float3 scale)
{
    return max(max(scale.x, scale.y), scale.z);
}

// Frustum culling check - tests if a sphere intersects the view frustum
bool IsSphereInFrustum(float3 center, float radius)
{
    float4 clipPos = mul(_ViewProjectionMatrix, float4(center, 1.0));

    // Perspective divide with safety check
    if (clipPos.w < 0.0001)
        return false;

    float3 ndc = clipPos.xyz / clipPos.w;

    // Apply frustum padding to radius
    float paddedRadius = radius * (1.0 + _FrustumPadding);
    float ndcRadius = paddedRadius / clipPos.w;

    // Check against frustum planes with padding
    bool inside = ndc.x >= -1.0 - ndcRadius && ndc.x <= 1.0 + ndcRadius &&
                  ndc.y >= -1.0 - ndcRadius && ndc.y <= 1.0 + ndcRadius &&
                  ndc.z >= 0.0 - ndcRadius && ndc.z <= 1.0 + ndcRadius;

    return inside;
}

// Distance-based culling check
bool IsWithinDistanceRange(float3 position)
{
    float distance = length(position - _CameraPosition);
    return distance >= _NearClip && distance <= _FarClip;
}

// Calculate LOD level based on distance
int CalculateLODLevel(float3 position)
{
    float distance = length(position - _CameraPosition);

    if (distance < _LODDistances.x) return 0;
    if (distance < _LODDistances.y) return 1;
    if (distance < _LODDistances.z) return 2;
    if (distance < _LODDistances.w) return 3;
    return 4; // Beyond all LOD levels
}

// Determine if splat should be rendered at current LOD level
bool ShouldRenderAtLOD(uint index, int lodLevel)
{
    if (lodLevel >= 4) return false; // Beyond max LOD

    float decimation = _LODDecimation[lodLevel];
    if (decimation >= 1.0) return true; // No decimation

    // Use stable hash-based decimation to maintain temporal coherence
    // This ensures the same splats are selected each frame for a given LOD
    uint hash = index * 2654435761u; // Knuth's multiplicative hash
    float hashNorm = (float)(hash % 10000) / 10000.0;

    return hashNorm < decimation;
}

[numthreads(256, 1, 1)]
void FrustumCull(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 position = _InputPositions[id.x];
    float3 scale = _InputScales[id.x];
    float radius = GetMaxScale(scale);

    bool visible = IsSphereInFrustum(position, radius);
    _VisibilityMask[id.x] = visible ? 1 : 0;

    if (visible)
    {
        uint outputIndex;
        InterlockedAdd(_VisibleCount[0], 1, outputIndex);

        if (outputIndex < _SplatCount)
        {
            _VisibleIndices[outputIndex] = id.x;
        }
    }
}

[numthreads(256, 1, 1)]
void DistanceCull(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 position = _InputPositions[id.x];

    bool visible = IsWithinDistanceRange(position);
    _VisibilityMask[id.x] = visible ? 1 : 0;

    if (visible)
    {
        uint outputIndex;
        InterlockedAdd(_VisibleCount[0], 1, outputIndex);

        if (outputIndex < _SplatCount)
        {
            _VisibleIndices[outputIndex] = id.x;
        }
    }
}

[numthreads(256, 1, 1)]
void LODSelect(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 position = _InputPositions[id.x];
    int lodLevel = CalculateLODLevel(position);

    bool visible = ShouldRenderAtLOD(id.x, lodLevel);
    _VisibilityMask[id.x] = visible ? 1 : 0;

    if (visible)
    {
        uint outputIndex;
        InterlockedAdd(_VisibleCount[0], 1, outputIndex);

        if (outputIndex < _SplatCount)
        {
            _VisibleIndices[outputIndex] = id.x;
        }
    }
}

[numthreads(256, 1, 1)]
void CombinedCullAndLOD(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 position = _InputPositions[id.x];
    float3 scale = _InputScales[id.x];
    float radius = GetMaxScale(scale);

    // Multi-stage culling for optimal performance
    // Stage 1: Distance culling (cheapest)
    if (!IsWithinDistanceRange(position))
    {
        _VisibilityMask[id.x] = 0;
        return;
    }

    // Stage 2: LOD culling
    int lodLevel = CalculateLODLevel(position);
    if (!ShouldRenderAtLOD(id.x, lodLevel))
    {
        _VisibilityMask[id.x] = 0;
        return;
    }

    // Stage 3: Frustum culling (most expensive)
    if (!IsSphereInFrustum(position, radius))
    {
        _VisibilityMask[id.x] = 0;
        return;
    }

    // Passed all culling tests
    _VisibilityMask[id.x] = 1;

    uint outputIndex;
    InterlockedAdd(_VisibleCount[0], 1, outputIndex);

    if (outputIndex < _SplatCount)
    {
        _VisibleIndices[outputIndex] = id.x;

        // Copy data to output buffers for compact rendering
        _OutputPositions[outputIndex] = position;
        _OutputScales[outputIndex] = scale;
        _OutputRotations[outputIndex] = _InputRotations[id.x];
        _OutputColors[outputIndex] = _InputColors[id.x];
        _OutputOpacities[outputIndex] = _InputOpacities[id.x];
    }
}
