// Compression and decompression compute shader for Gaussian Splats
// Supports quantization and delta compression for baked sequences
#pragma kernel Compress
#pragma kernel Decompress
#pragma kernel DeltaCompress
#pragma kernel DeltaDecompress

// Uncompressed data
StructuredBuffer<float3> _InputPositions;
StructuredBuffer<float3> _InputScales;
StructuredBuffer<float4> _InputRotations;
StructuredBuffer<float4> _InputColors;
StructuredBuffer<float> _InputOpacities;

// Compressed data (using reduced precision)
RWStructuredBuffer<uint> _CompressedPositions; // 3x 16-bit per position
RWStructuredBuffer<uint> _CompressedScales; // 3x 16-bit per scale
RWStructuredBuffer<uint> _CompressedRotations; // 4x 16-bit per rotation
RWStructuredBuffer<uint> _CompressedColors; // RGBA8888
RWStructuredBuffer<uint> _CompressedOpacities; // 8-bit per opacity

// Decompressed output
RWStructuredBuffer<float3> _OutputPositions;
RWStructuredBuffer<float3> _OutputScales;
RWStructuredBuffer<float4> _OutputRotations;
RWStructuredBuffer<float4> _OutputColors;
RWStructuredBuffer<float> _OutputOpacities;

// Compression parameters
float3 _BoundsMin;
float3 _BoundsMax;
float3 _ScaleMin;
float3 _ScaleMax;
uint _SplatCount;

// Delta compression (for sequences)
StructuredBuffer<float3> _PreviousPositions;
RWStructuredBuffer<int> _DeltaPositions; // Delta encoded positions

// Utility functions for quantization
uint FloatToUint16(float value, float minVal, float maxVal)
{
    float normalized = saturate((value - minVal) / (maxVal - minVal));
    return (uint)(normalized * 65535.0);
}

float Uint16ToFloat(uint value, float minVal, float maxVal)
{
    float normalized = (float)value / 65535.0;
    return lerp(minVal, maxVal, normalized);
}

uint PackFloat3ToUint2(float3 value, float3 minVal, float3 maxVal)
{
    // Pack 3 floats into 2 uints (48 bits total, 16 bits each)
    uint x = FloatToUint16(value.x, minVal.x, maxVal.x);
    uint y = FloatToUint16(value.y, minVal.y, maxVal.y);
    return (x << 16) | y;
}

uint PackFloat3ToUint2_Z(float3 value, float3 minVal, float3 maxVal)
{
    // Pack Z component separately
    uint z = FloatToUint16(value.z, minVal.z, maxVal.z);
    return z;
}

float3 UnpackUint2ToFloat3(uint packed1, uint packed2, float3 minVal, float3 maxVal)
{
    uint x = (packed1 >> 16) & 0xFFFF;
    uint y = packed1 & 0xFFFF;
    uint z = packed2 & 0xFFFF;

    return float3(
        Uint16ToFloat(x, minVal.x, maxVal.x),
        Uint16ToFloat(y, minVal.y, maxVal.y),
        Uint16ToFloat(z, minVal.z, maxVal.z)
    );
}

uint PackFloat4ToUint2(float4 value)
{
    // Normalize quaternion and pack (assuming unit quaternion)
    float4 normalized = normalize(value);

    // Convert from [-1, 1] to [0, 1]
    float4 positive = normalized * 0.5 + 0.5;

    uint x = (uint)(positive.x * 65535.0);
    uint y = (uint)(positive.y * 65535.0);

    return (x << 16) | y;
}

uint PackFloat4ToUint2_ZW(float4 value)
{
    float4 normalized = normalize(value);
    float4 positive = normalized * 0.5 + 0.5;

    uint z = (uint)(positive.z * 65535.0);
    uint w = (uint)(positive.w * 65535.0);

    return (z << 16) | w;
}

float4 UnpackUint2ToFloat4(uint packed1, uint packed2)
{
    uint x = (packed1 >> 16) & 0xFFFF;
    uint y = packed1 & 0xFFFF;
    uint z = (packed2 >> 16) & 0xFFFF;
    uint w = packed2 & 0xFFFF;

    float4 positive = float4(
        (float)x / 65535.0,
        (float)y / 65535.0,
        (float)z / 65535.0,
        (float)w / 65535.0
    );

    // Convert back from [0, 1] to [-1, 1]
    float4 result = positive * 2.0 - 1.0;
    return normalize(result); // Ensure unit quaternion
}

uint PackColorRGBA8(float4 color)
{
    uint r = (uint)(saturate(color.r) * 255.0);
    uint g = (uint)(saturate(color.g) * 255.0);
    uint b = (uint)(saturate(color.b) * 255.0);
    uint a = (uint)(saturate(color.a) * 255.0);

    return (r << 24) | (g << 16) | (b << 8) | a;
}

float4 UnpackColorRGBA8(uint packed)
{
    uint r = (packed >> 24) & 0xFF;
    uint g = (packed >> 16) & 0xFF;
    uint b = (packed >> 8) & 0xFF;
    uint a = packed & 0xFF;

    return float4(
        (float)r / 255.0,
        (float)g / 255.0,
        (float)b / 255.0,
        (float)a / 255.0
    );
}

[numthreads(256, 1, 1)]
void Compress(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 position = _InputPositions[id.x];
    float3 scale = _InputScales[id.x];
    float4 rotation = _InputRotations[id.x];
    float4 color = _InputColors[id.x];
    float opacity = _InputOpacities[id.x];

    // Compress position (2 uints for 3 floats)
    uint posIndex = id.x * 2;
    _CompressedPositions[posIndex] = PackFloat3ToUint2(position, _BoundsMin, _BoundsMax);
    _CompressedPositions[posIndex + 1] = PackFloat3ToUint2_Z(position, _BoundsMin, _BoundsMax);

    // Compress scale (2 uints for 3 floats)
    uint scaleIndex = id.x * 2;
    _CompressedScales[scaleIndex] = PackFloat3ToUint2(scale, _ScaleMin, _ScaleMax);
    _CompressedScales[scaleIndex + 1] = PackFloat3ToUint2_Z(scale, _ScaleMin, _ScaleMax);

    // Compress rotation (2 uints for 4 floats)
    uint rotIndex = id.x * 2;
    _CompressedRotations[rotIndex] = PackFloat4ToUint2(rotation);
    _CompressedRotations[rotIndex + 1] = PackFloat4ToUint2_ZW(rotation);

    // Compress color (1 uint for RGBA)
    _CompressedColors[id.x] = PackColorRGBA8(color);

    // Compress opacity (pack 4 opacities into 1 uint)
    uint opacityIndex = id.x / 4;
    uint opacityOffset = (id.x % 4) * 8;
    uint packedOpacity = (uint)(saturate(opacity) * 255.0) << opacityOffset;

    // Atomic OR to combine 4 opacities
    InterlockedOr(_CompressedOpacities[opacityIndex], packedOpacity);
}

[numthreads(256, 1, 1)]
void Decompress(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    // Decompress position
    uint posIndex = id.x * 2;
    _OutputPositions[id.x] = UnpackUint2ToFloat3(
        _CompressedPositions[posIndex],
        _CompressedPositions[posIndex + 1],
        _BoundsMin,
        _BoundsMax
    );

    // Decompress scale
    uint scaleIndex = id.x * 2;
    _OutputScales[id.x] = UnpackUint2ToFloat3(
        _CompressedScales[scaleIndex],
        _CompressedScales[scaleIndex + 1],
        _ScaleMin,
        _ScaleMax
    );

    // Decompress rotation
    uint rotIndex = id.x * 2;
    _OutputRotations[id.x] = UnpackUint2ToFloat4(
        _CompressedRotations[rotIndex],
        _CompressedRotations[rotIndex + 1]
    );

    // Decompress color
    _OutputColors[id.x] = UnpackColorRGBA8(_CompressedColors[id.x]);

    // Decompress opacity
    uint opacityIndex = id.x / 4;
    uint opacityOffset = (id.x % 4) * 8;
    uint packedOpacities = _CompressedOpacities[opacityIndex];
    uint opacityByte = (packedOpacities >> opacityOffset) & 0xFF;
    _OutputOpacities[id.x] = (float)opacityByte / 255.0;
}

[numthreads(256, 1, 1)]
void DeltaCompress(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 current = _InputPositions[id.x];
    float3 previous = _PreviousPositions[id.x];
    float3 delta = current - previous;

    // Quantize delta to 16-bit signed integers
    int deltaX = (int)(clamp(delta.x, -32.0, 32.0) * 1000.0);
    int deltaY = (int)(clamp(delta.y, -32.0, 32.0) * 1000.0);
    int deltaZ = (int)(clamp(delta.z, -32.0, 32.0) * 1000.0);

    // Pack into buffer (3 ints per position)
    uint deltaIndex = id.x * 3;
    _DeltaPositions[deltaIndex] = deltaX;
    _DeltaPositions[deltaIndex + 1] = deltaY;
    _DeltaPositions[deltaIndex + 2] = deltaZ;
}

[numthreads(256, 1, 1)]
void DeltaDecompress(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _SplatCount)
        return;

    float3 previous = _PreviousPositions[id.x];

    // Unpack delta
    uint deltaIndex = id.x * 3;
    int deltaX = _DeltaPositions[deltaIndex];
    int deltaY = _DeltaPositions[deltaIndex + 1];
    int deltaZ = _DeltaPositions[deltaIndex + 2];

    float3 delta = float3(
        (float)deltaX / 1000.0,
        (float)deltaY / 1000.0,
        (float)deltaZ / 1000.0
    );

    _OutputPositions[id.x] = previous + delta;
}
